import{ah as i,ai as o,ap as t,aj as e}from"./app-CfkHjtyy.js";const n="/assets/image-BBY8ATH2.png",r="/assets/image-1-CYKY3h9m.png",s={};function a(d,l){return e(),o("div",null,l[0]||(l[0]=[t('<h1 id="嵌入式linux系统移植学习笔记" tabindex="-1"><a class="header-anchor" href="#嵌入式linux系统移植学习笔记"><span>嵌入式Linux系统移植学习笔记</span></a></h1><h2 id="嵌入式linux系统移植概述" tabindex="-1"><a class="header-anchor" href="#嵌入式linux系统移植概述"><span>嵌入式Linux系统移植概述</span></a></h2><h3 id="嵌入式linux系统构成" tabindex="-1"><a class="header-anchor" href="#嵌入式linux系统构成"><span>嵌入式Linux系统构成</span></a></h3><p><strong>典型嵌入式Linux系统的组成部分</strong></p><ul><li><code>bootloder</code> 引导程序</li><li><code>kernel</code> Linux内核</li><li><code>fs</code> 文件系统 <ul><li>存放用户态的可执行程序和数据</li><li><code>rootfs</code> 系统级可执行程序</li><li><code>datafs/userfs</code> 用户数据</li></ul></li></ul><p><strong>什么是移植？</strong></p><ul><li>修改<code>bootloder</code>源代码</li><li>修改<code>kernel</code>源代码</li><li>修改文件系统中用户态<code>可执行程序</code>源代码</li><li><strong>目的：使其能够在目标硬件平台运行</strong></li></ul><h3 id="bootloder" tabindex="-1"><a class="header-anchor" href="#bootloder"><span>Bootloder</span></a></h3><p><strong>Bootloder的作用</strong></p><blockquote><p>在PC电脑上，操作系统的引导工作通常由 <strong>BIOS引导程序</strong> 和 <strong><code>MBR分区表的第一个扇区</code>或<code>GPT分区表的EFI分区</code></strong> 配合完成；<br> 而嵌入式系统通常没有BIOS固件程序，因此整个系统的引导工作由bootloder来完成</p></blockquote><ul><li>负责初始化硬件设备</li><li>建立内存空间映射图</li><li>准备好合适的软硬件环境</li><li>以便最终调用操作系统内核程序</li></ul><p><strong>Bootloder的特点</strong></p><ul><li>Bootloder不是操作系统内核代码</li><li>Bootloder代码是针对特点CPU架构的汇编代码，不可移植。</li><li>Bootloder代码依赖CPU架构 同时依赖嵌入式系统板级配置</li></ul><p><strong>Bootloder程序的基本流程</strong></p><ul><li>初始化硬件</li><li>将操作系统内核从Flash（存储器）拷贝到SDRAM（内存）中；</li><li>改写系统的内存映射 <ul><li>由Flash起始地址为0 改为SDRAM起始地址为0</li></ul></li><li>设置堆栈指针 清零BSS段 <ul><li>执行C程序和调用子函数要用到。</li></ul></li><li>提供Linux内核启动参数</li><li>启动Linux内核</li><li>改变PC寄存器的值，使得CPU开始执行真正的操作系统内核。</li></ul><h3 id="kernel" tabindex="-1"><a class="header-anchor" href="#kernel"><span>Kernel</span></a></h3><p><strong>Linux内核功能</strong></p><ul><li>内存管理： <ul><li>裸板开发操作物理地址</li><li>linux软件开发可以<code>malloc()</code>获取虚拟地址</li></ul></li><li>进程管理/进程通信 <ul><li>裸板开发通过RTOS实现多任务</li><li>linux软件开发通过<code>fork()</code>实现多任务</li></ul></li><li>文件系统 <ul><li>裸板开发需要手动管理数据，精确到字节，需考虑存储地址、偏移、写入字节数</li><li>linux软件开发通过文件系统管理数据，精确到文件</li></ul></li><li>设备管理</li><li>网络协议 <ul><li>linux是对网络协议支持最全的操作系统</li><li>TCP/UDP/IP 协议都在linux源代码中有实现</li></ul></li></ul><p><strong>内核的本质</strong></p><ul><li>从C语言角度看内核：c语言函数的集合。</li><li>从硬件角度看内核：硬件的管理者和维护者。</li><li>从应用程序角度看内核：服务提供者。</li></ul><h3 id="fs文件系统" tabindex="-1"><a class="header-anchor" href="#fs文件系统"><span>fs文件系统</span></a></h3><p><strong>嵌入式文件系统</strong></p><ul><li>是一种对存储设备上的数据进行组织管理的控制机制</li><li>是操作系统的一部分，负责管理和存储文件。</li></ul><p><strong>嵌入式Linux系统中典型的存储子系统层次化架构</strong></p><ul><li><strong>用户层 (User Layer)</strong><ul><li><strong>目录树</strong>：为用户和应用程序提供统一的文件访问视图。用户通过路径（如 <code>/home/data/file.txt</code>）来操作文件，完全无需关心文件实际存储在哪种介质上。</li></ul></li><li><strong>内核层 (Kernel Layer)</strong><ul><li><strong>虚拟文件系统 (VFS)</strong>：这是整个架构的<strong>核心抽象层</strong>。它定义了一组标准的文件操作接口（如 <code>open</code>, <code>read</code>, <code>write</code>, <code>close</code>）。上层应用只需与VFS交互，而VFS负责将这些通用调用“翻译”并路由到下层的具体文件系统。</li><li><strong>具体文件系统</strong>：VFS之下是各种针对不同存储介质优化的文件系统实现： <ul><li><strong>JFFS2, YAFFS</strong>：专为<strong>Nand Flash</strong>设计的日志闪存文件系统，处理了闪存特有的擦除、读写均衡、坏块管理等问题。</li><li><strong>Cramfs, Romfs</strong>：只读的压缩文件系统，常用于存放固件、系统程序等不变的数据，节省空间。</li><li><strong>Ramdisk</strong>：将一部分内存（RAM）虚拟成块设备，作为临时性的高速文件系统，但掉电数据会丢失。</li></ul></li></ul></li><li><strong>驱动层 (Driver Layer)</strong><ul><li><strong>MTD子系统</strong>：这是Linux内核为<strong>内存技术设备</strong>设计的统一驱动框架，专门用于管理各类闪存。 <ul><li><strong>MTD设备驱动</strong>：直接操作具体的Flash硬件（如某型号的Nor或Nand Flash芯片），负责最底层的读写、擦除命令。</li><li><strong>MTD字符/块设备</strong>：MTD向上提供的两种视图。 <ul><li><strong>MTD字符设备</strong>：提供对闪存的原始、字节级访问（如用于烧写引导程序）。</li><li><strong>MTD块设备</strong>：将闪存模拟成标准的块设备（类似硬盘），这样上层的文件系统（如JFFS2）就可以像操作普通磁盘一样在其上创建文件系统。</li></ul></li></ul></li></ul></li><li><strong>硬件层 (Hardware Layer)</strong><ul><li><strong>Nor Flash</strong>：支持芯片内执行，读写速度快，但价格高、容量小，常用于存储启动代码。</li><li><strong>Nand Flash</strong>：容量大、成本低，是主要的存储介质，但需要复杂的坏块管理和磨损均衡。</li><li><strong>RAM</strong>：易失性存储器，速度快，用于Ramdisk或作为系统缓存。</li></ul></li><li><img src="'+n+'" alt="alt text"></li><li><img src="'+r+'" alt="alt text"></li></ul><hr><p><strong>关键技术与数据流</strong></p><ol><li><strong>VFS的抽象作用</strong>：VFS是连接用户空间和多样存储后端的桥梁，它使得 <code>ext4</code>, <code>FAT32</code>, <code>JFFS2</code> 等不同文件系统可以在Linux中共存，对用户透明。</li><li><strong>MTD的标准化意义</strong>：在MTD出现之前，每种Flash都需要为其文件系统编写专用驱动，耦合度高。MTD定义了标准的Flash操作接口，将<strong>闪存驱动</strong>和<strong>闪存文件系统</strong>解耦。文件系统基于MTD接口开发，驱动则实现MTD接口，二者可以独立开发和替换。</li><li><strong>完整数据访问路径示例</strong><br> 当用户执行 <code>cat /mnt/nand/example.txt</code> 时： <ol><li>用户层通过路径发起请求。</li><li>VFS解析路径，发现 <code>/mnt/nand</code> 挂载的是YAFFS2文件系统。</li><li>VFS调用YAFFS2文件系统的 <code>read</code> 方法。</li><li>YAFFS2文件系统将文件操作转换为对逻辑块地址的请求，并通过MTD块设备接口下发。</li><li>MTD子系统将块设备请求转换为对具体Nand Flash芯片的读操作序列。</li><li>MTD设备驱动操控硬件，从Nand Flash中读取数据，并按原路返回给用户。</li></ol></li></ol><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p><strong>bootloder</strong></p><ul><li>硬件上电后固定跳转到该位置执行代码</li><li>初始化相应硬件设备</li><li>加载操作系统内核代码到内存</li><li>跳转到内核代码的起始位置开始执行</li></ul><p><strong>kernel</strong></p><ul><li>内核自解压ulmage</li><li>初始化硬件设备</li><li>初始化静态编译进内核的驱动模块</li><li>挂载根文件系统</li><li>执行第一个用户空间程序</li></ul><p><strong>第一个用户空间程序</strong></p><ul><li>配置用户环境</li><li>执行服务进程</li></ul>',35)]))}const g=i(s,[["render",a]]),c=JSON.parse('{"path":"/%E7%94%B5%E5%AD%90/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"嵌入式Linux系统移植学习笔记","lang":"zh-CN","frontmatter":{"tittle":"嵌入式Linux系统移植学习笔记","date":"2025-12-11T18:01:00.000Z","tag":["嵌入式"],"category":"电子","article":false,"description":"嵌入式Linux系统移植学习笔记 嵌入式Linux系统移植概述 嵌入式Linux系统构成 典型嵌入式Linux系统的组成部分 bootloder 引导程序 kernel Linux内核 fs 文件系统 存放用户态的可执行程序和数据 rootfs 系统级可执行程序 datafs/userfs 用户数据 什么是移植？ 修改bootloder源代码 修改ke...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"WebPage\\",\\"name\\":\\"嵌入式Linux系统移植学习笔记\\",\\"description\\":\\"嵌入式Linux系统移植学习笔记 嵌入式Linux系统移植概述 嵌入式Linux系统构成 典型嵌入式Linux系统的组成部分 bootloder 引导程序 kernel Linux内核 fs 文件系统 存放用户态的可执行程序和数据 rootfs 系统级可执行程序 datafs/userfs 用户数据 什么是移植？ 修改bootloder源代码 修改ke...\\"}"],["meta",{"property":"og:url","content":"https://dingdingdang.online/%E7%94%B5%E5%AD%90/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],["meta",{"property":"og:site_name","content":"YiguiDing的Blog小站"}],["meta",{"property":"og:title","content":"嵌入式Linux系统移植学习笔记"}],["meta",{"property":"og:description","content":"嵌入式Linux系统移植学习笔记 嵌入式Linux系统移植概述 嵌入式Linux系统构成 典型嵌入式Linux系统的组成部分 bootloder 引导程序 kernel Linux内核 fs 文件系统 存放用户态的可执行程序和数据 rootfs 系统级可执行程序 datafs/userfs 用户数据 什么是移植？ 修改bootloder源代码 修改ke..."}],["meta",{"property":"og:type","content":"website"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-11T18:03:39.000Z"}],["meta",{"property":"article:tag","content":"嵌入式"}],["meta",{"property":"article:published_time","content":"2025-12-11T18:01:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-12-11T18:03:39.000Z"}],["meta",{"name":"baidu-site-verification","content":"codeva-PwE9Ts6nMl"}]]},"git":{"createdTime":1765476219000,"updatedTime":1765476219000,"contributors":[{"name":"YiguiDing","username":"YiguiDing","email":"2449695354@qq.com","commits":1,"url":"https://github.com/YiguiDing"}]},"readingTime":{"minutes":5.73,"words":1719},"filePathRelative":"电子/嵌入式Linux系统移植学习笔记/README.md","excerpt":"","autoDesc":true}');export{g as comp,c as data};
